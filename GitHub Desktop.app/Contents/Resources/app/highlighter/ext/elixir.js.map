{"version":3,"sources":["webpack:///./app/node_modules/codemirror-mode-elixir/dist/elixir.mjs"],"names":[],"mappings":"iFAGA,GACA,iCACA,kBACA,WACA,WAAqC,OAAO,IAC5C,MACA,SACA,QAEA,gVACA,kFACA,YACA,UAAkB,SAAa,IAAK,QAEpC,WAEA,oBACA,mBACA,QACA,MAEA,iBACA,kCACA,wBACA,QAGA,eACA,iBAGA,cACA,aAEA,eACA,+BACK,0BACL,mBACA,wBACA,mBACA,SAEA,2BAEA,gCACA,SACA,UACA,WACW,EACX,aAEA,GACA,IAEA,KAEA,yBAEA,UACA,kBAEA,mBAEA,OACA,UAAK,YACL,OACA,SAEA,WACA,OACO,aACP,UACO,eACP,SACO,iBACP,aACA,SAGA,kBAGA,wBAIA,4BAGA,QACA,kBALA,UAKK,IACL,iBACA,YACK,iCACL,8DACK,YACL,qBACA,gBACO,oBACP,gBAEA,mBAEA,SACK,iBACL,uBACA,6CACK,oBACL,cAEA,2BACA,iBAEA,QAEA,OACA,QAAK,OACL,cACA,aAEA,sBACA,eAIA,sBACA,iBACA,UAIA,cACA,sBAIA,aACA,sCAEA,0BACA,YAGA,QACK,4BACL,kCACA,gBACA,mBACK,cACL,eACA,wBACO,cACP,YAEA,QAEA,OACK,qCACL,oBACA,yBACA,gBACA,KAEA,OACK,8BAA8D,iBACnE,qBACA,IACK,MAAyB,kBAC9B,SACA,IACK,qBACL,KACK,uBACL,KACK,4BACL,6BACA,0BAEA,KAEA,YAEA,IAEA,iBAEA,cAGA,gBACA,IAA8B,eAC9B,IACA,wBACA,mCAEA,4CAEA,EAAO,KACP,qDAEA,UACA,OACA,CAEA,cACA,IACA,0BAEA,sBACA,mCAEA,UACA,KACA,OACA,CAEA,qBACA,qBACA,IACA,YAEA,OACA,4DACA,WAGA,0BAEA,mBACA,YACA,MACA,KAEA,gBACA,YAA2B,KAC3B,CACA,oBAA+B,qBAE/B,uCACA,KACA,KAAW,gCACX,iBACA,KACA,KAGA,OACA,QAEA,CACA,QACA,CAEA,eACA,qBACA,UACA,oBAEA,QAEA,YACA,QACA,CAEA,iBACA,sCACA,kBAEA,QACA,YACA,SAEA,QACA,sBACA,OACA,UACA,aACA,UAAkB,wBAClB,YACA,yBACA,KAEA,WACA,qBACA,GAMA,wCACA,cACA,GAEA,mBACA,SAEA,oKAEA,gCACA,cACA,eACA,MACA,0BACW,WACX,0BACW,oBACX,mBACW,wCACX,aAGA,UAEA,CAuBA,aAtBA,mBAGA,WACA,uBAGA,uBAAyC,WACzC,kBACA,QACA,aACA,gBAEO,wBAA0C,+BACjD,2BAGA,QACA,kCAGA,iBAaA,gBACA,uDAEA,IAAC,GAED","file":"highlighter/ext/elixir.js","sourcesContent":["import CodeMirror from 'codemirror';\n\n// CodeMirror Mode Elixir, copyright (c) by Marijn Haverbeke, Ian Walter, and\n// others. Distributed under an MIT license: http://codemirror.net/LICENSE.\nCodeMirror.defineMode('elixir', function (config) {\n  var wordObj = function wordObj(words) {\n    var o = {};\n    for (var i = 0, e = words.length; i < e; ++i) {\n      o[words[i]] = true;\n    }return o;\n  };\n\n  var keywords = wordObj(['alias', 'case', 'cond', 'def', 'defmodule', 'defp', 'defstruct', 'defprotocol', 'defimpl', 'defmacro', 'quote', 'unquote', 'receive', 'fn', 'do', 'else', 'else if', 'end', 'false', 'if', 'in', 'next', 'rescue', 'for', 'true', 'unless', 'when', 'nil', 'raise', 'throw', 'try', 'catch', 'after', 'with', 'require', 'use', '__MODULE__', '__FILE__', '__DIR__', '__ENV__', '__CALLER__']);\n  var indentWords = wordObj(['def', 'defmodule', 'defp', 'case', 'cond', 'rescue', 'try', 'catch', '->']);\n  var dedentWords = wordObj(['end']);\n  var matching = { '[': ']', '{': '}', '(': ')' };\n\n  var curPunc = void 0;\n\n  var chain = function chain(newtok, stream, state) {\n    state.tokenize.push(newtok);\n    return newtok(stream, state);\n  };\n\n  var tokenBase = function tokenBase(stream, state) {\n    if (stream.sol() && stream.match('\"\"\"') && stream.eol()) {\n      state.tokenize.push(readBlockComment);\n      return 'comment';\n    }\n\n    if (stream.eatSpace()) {\n      return null;\n    }\n\n    var ch = stream.next();\n    var m = void 0;\n\n    if (ch === '\\'' || ch === '\"') {\n      return chain(readQuoted(ch, 'string', ch === '\"'), stream, state);\n    } else if (ch === '/') {\n      var currentIndex = stream.current().length;\n      if (stream.skipTo('/')) {\n        var searchTill = stream.current().length;\n        var balance = 0; // balance brackets\n\n        stream.backUp(stream.current().length - currentIndex);\n\n        while (stream.current().length < searchTill) {\n          var chchr = stream.next();\n          if (chchr === '(') {\n            balance += 1;\n          } else if (chchr === ')') {\n            balance -= 1;\n          }\n          if (balance < 0) {\n            break;\n          }\n        }\n\n        stream.backUp(stream.current().length - currentIndex);\n\n        if (balance === 0) {\n          return chain(readQuoted(ch, 'string-2', true), stream, state);\n        }\n      }\n\n      return 'operator';\n    } else if (ch === '%') {\n      var style = 'string';\n      var embed = true;\n\n      if (stream.eat('s')) {\n        style = 'atom';\n      } else if (stream.eat(/[WQ]/)) {\n        style = 'string';\n      } else if (stream.eat(/[r]/)) {\n        style = 'string-2';\n      } else if (stream.eat(/[wxq]/)) {\n        style = 'string';\n        embed = false;\n      }\n\n      var delim = stream.eat(/[^\\w\\s=]/);\n\n      if (!delim) {\n        return 'operator';\n      }\n\n      if (matching.propertyIsEnumerable(delim)) {\n        delim = matching[delim];\n      }\n\n      return chain(readQuoted(delim, style, embed, true), stream, state);\n    } else if (ch === '#') {\n      stream.skipToEnd();\n      return 'comment';\n    } else if (ch === '<' && (m = stream.match(/^<-?[\\`\\\"\\']?([a-zA-Z_?]\\w*)[\\`\\\"\\']?(?:;|$)/))) {\n      return chain(readHereDoc(m[1]), stream, state);\n    } else if (ch === '0') {\n      if (stream.eat('x')) {\n        stream.eatWhile(/[\\da-fA-F]/);\n      } else if (stream.eat('b')) {\n        stream.eatWhile(/[01]/);\n      } else {\n        stream.eatWhile(/[0-7]/);\n      }\n      return 'number';\n    } else if (/\\d/.test(ch)) {\n      stream.match(/^[\\d_]*(?:\\.[\\d_]+)?(?:[eE][+\\-]?[\\d_]+)?/);\n      return 'number';\n    } else if (ch === '?') {\n      while (stream.match(/^\\\\[CM]-/)) {}\n\n      if (stream.eat('\\\\')) {\n        stream.eatWhile(/\\w/);\n      } else {\n        stream.next();\n      }\n      return 'string';\n    } else if (ch === ':') {\n      if (stream.eat('\\'')) {\n        return chain(readQuoted('\\'', 'atom', false), stream, state);\n      }\n      if (stream.eat('\"')) {\n        return chain(readQuoted('\"', 'atom', true), stream, state);\n      }\n\n      // :> :>> :< :<< are valid symbols\n      if (stream.eat(/[\\<\\>]/)) {\n        stream.eat(/[\\<\\>]/);\n        return 'atom';\n      }\n\n      // :+ :- :/ :* :| :& :! are valid symbols\n      if (stream.eat(/[\\+\\-\\*\\/\\&\\|\\:\\!]/)) {\n        return 'atom';\n      }\n\n      // Symbols can't start by a digit\n      if (stream.eat(/[a-zA-Z$@_\\xa1-\\uffff]/)) {\n        stream.eatWhile(/[\\w$\\xa1-\\uffff]/);\n        // Only one ? ! = is allowed and only as the last character\n        stream.eat(/[\\?\\!\\=]/);\n        return 'atom';\n      }\n\n      return 'operator';\n    } else if (ch === '@' && stream.match(/^@?[a-zA-Z_\\xa1-\\uffff]/)) {\n      stream.eat('@');\n      stream.eatWhile(/[\\w\\xa1-\\uffff]/);\n      return 'variable-2';\n    } else if (ch === '$') {\n      if (stream.eat(/[a-zA-Z_]/)) {\n        stream.eatWhile(/[\\w]/);\n      } else if (stream.eat(/\\d/)) {\n        stream.eat(/\\d/);\n      } else {\n        stream.next(); // Must be a special global like $: or $!\n      }\n      return 'variable-3';\n    } else if (/[a-zA-Z_\\xa1-\\uffff]/.test(ch)) {\n      stream.eatWhile(/[\\w\\xa1-\\uffff]/);\n      stream.eat(/[\\?\\!]/);\n      if (stream.eat(':')) {\n        return 'atom';\n      }\n      return 'ident';\n    } else if (ch === '|' && (state.varList || state.lastTok === '{' || state.lastTok === 'do')) {\n      curPunc = '|';\n      return null;\n    } else if (/[\\(\\)\\[\\]{}\\\\;]/.test(ch)) {\n      curPunc = ch;\n      return null;\n    } else if (ch === '-' && stream.eat('>')) {\n      return 'arrow';\n    } else if (ch === '|' && stream.eat('>')) {\n      return 'pipe';\n    } else if (/[=+\\-\\/*:\\.^%<>~|]/.test(ch)) {\n      if (ch === '.' && !stream.eatWhile(/[=+\\-\\/*:\\.^%<>~|]/)) {\n        curPunc = '.';\n      }\n      return 'operator';\n    } else {\n      return null;\n    }\n  };\n\n  var tokenBaseUntilBrace = function tokenBaseUntilBrace(depth) {\n    if (!depth) {\n      depth = 1;\n    }\n\n    return function (stream, state) {\n      if (stream.peek() === '}') {\n        if (depth === 1) {\n          state.tokenize.pop();\n          return state.tokenize[state.tokenize.length - 1](stream, state);\n        } else {\n          state.tokenize[state.tokenize.length - 1] = tokenBaseUntilBrace(depth - 1);\n        }\n      } else if (stream.peek() === '{') {\n        state.tokenize[state.tokenize.length - 1] = tokenBaseUntilBrace(depth + 1);\n      }\n      return tokenBase(stream, state);\n    };\n  };\n\n  var tokenBaseOnce = function tokenBaseOnce() {\n    var alreadyCalled = false;\n    return function (stream, state) {\n      if (alreadyCalled) {\n        state.tokenize.pop();\n        return state.tokenize[state.tokenize.length - 1](stream, state);\n      }\n      alreadyCalled = true;\n      return tokenBase(stream, state);\n    };\n  };\n\n  var readQuoted = function readQuoted(quote, style, embed, unescaped) {\n    return function (stream, state) {\n      var escaped = false;\n      var ch = void 0;\n\n      if (state.context.type === 'read-quoted-paused') {\n        state.context = state.context.prev;\n        stream.eat('}');\n      }\n\n      while ((ch = stream.next()) != null) {\n        // eslint-disable-line\n        if (ch === quote && (unescaped || !escaped)) {\n          state.tokenize.pop();\n          break;\n        }\n\n        if (embed && ch === '#' && !escaped) {\n          if (stream.eat('{')) {\n            if (quote === '}') {\n              state.context = { prev: state.context, type: 'read-quoted-paused' };\n            }\n            state.tokenize.push(tokenBaseUntilBrace());\n            break;\n          } else if (/[@\\$]/.test(stream.peek())) {\n            state.tokenize.push(tokenBaseOnce());\n            break;\n          }\n        }\n\n        escaped = !escaped && ch === '\\\\';\n      }\n\n      return style;\n    };\n  };\n\n  var readHereDoc = function readHereDoc(phrase) {\n    return function (stream, state) {\n      if (stream.match(phrase)) {\n        state.tokenize.pop();\n      } else {\n        stream.skipToEnd();\n      }\n      return 'string';\n    };\n  };\n\n  var readBlockComment = function readBlockComment(stream, state) {\n    if (stream.sol() && stream.match('\"\"\"') && stream.eol()) {\n      state.tokenize.pop();\n    }\n    stream.skipToEnd();\n    return 'comment';\n  };\n\n  return {\n    startState: function startState() {\n      return {\n        tokenize: [tokenBase],\n        indented: 0,\n        context: { type: 'top', indented: -config.indentUnit },\n        continuedLine: false,\n        lastTok: null,\n        varList: false\n      };\n    },\n    token: function token(stream, state) {\n      curPunc = null;\n\n      // if (stream.sol()) {\n      //   state.indented = stream.indentation()\n      // }\n\n      var style = state.tokenize[state.tokenize.length - 1](stream, state);\n      var kwtype = void 0;\n      var thisTok = curPunc;\n\n      if (style === 'ident') {\n        var word = stream.current();\n\n        style = state.lastTok === '.' ? 'property' : keywords.propertyIsEnumerable(stream.current()) ? 'keyword' : /^[A-Z]/.test(word) ? 'tag' : state.lastTok === 'def' || state.lastTok === 'class' || state.varList ? 'def' : 'variable';\n\n        var isColumnIndent = stream.column() === stream.indentation();\n        if (style === 'keyword') {\n          thisTok = word;\n          if (indentWords.propertyIsEnumerable(word)) {\n            kwtype = 'indent';\n          } else if (dedentWords.propertyIsEnumerable(word)) {\n            kwtype = 'dedent';\n          } else if ((word === 'if' || word === 'unless') && isColumnIndent) {\n            kwtype = 'indent';\n          } else if (word === 'do' && state.context.indented < state.indented) {\n            kwtype = 'indent';\n          }\n        }\n      }\n\n      if (curPunc || style && style !== 'comment') {\n        state.lastTok = thisTok;\n      }\n\n      if (curPunc === '|') {\n        state.varList = !state.varList;\n      }\n\n      if (kwtype === 'indent' || /[\\(\\[\\{]/.test(curPunc)) {\n        state.context = {\n          prev: state.context,\n          type: curPunc || style,\n          indented: state.indented\n        };\n      } else if ((kwtype === 'dedent' || /[\\)\\]\\}]/.test(curPunc)) && state.context.prev) {\n        state.context = state.context.prev;\n      }\n\n      if (stream.eol()) {\n        state.continuedLine = curPunc === '\\\\' || style === 'operator';\n      }\n\n      return style;\n    },\n    // indent: (state, textAfter) => {\n    //   if (state.tokenize[state.tokenize.length - 1] !== tokenBase) {\n    //     return 0\n    //   }\n    //   let firstChar = textAfter && textAfter.charAt(0)\n    //   let ct = state.context\n    //   let closing = ct.type === matching[firstChar] ||\n    //     ct.type === 'keyword' && /^(?:end|until|else|else if|when|rescue)\\b/.test(textAfter)\n    //   return ct.indented + (closing ? 0 : config.indentUnit) +\n    //     (state.continuedLine ? config.indentUnit : 0)\n    // },\n    electricInput: /^\\s*(?:end|rescue|else if|else|catch\\})$/,\n    lineComment: '#'\n  };\n});\n\nCodeMirror.defineMIME('text/x-elixir', 'elixir');\n"],"sourceRoot":""}