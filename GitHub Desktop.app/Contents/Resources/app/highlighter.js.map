{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./app/node_modules/codemirror/addon/runmode/runmode.node.js","webpack:///./app/src/highlighter/index.ts"],"names":[],"mappings":"YAAA,cAqBA,IACA,iBAGA,mBACA,CACA,IACA,aAIA,mCAGA,aAGA,OACA,OAIA,gCA1CA,QACA,aAEA,YACA,mBACA,CAGA,QAIA,KACA,aAIA,yBA0BA,OACA,kCAEA,CACA,qCAEA,MACA,mBACA,MAGA,IAGA,MAGA,uBACA,GACA,kCACA,CACA,gBACA,cAGA,OAGA,iBACA,sCAAiD,CACjD,UAGA,iBACA,YACA,qBAA2B,UAA0B,UACrD,YAAiC,CAAe,QAChD,EAEA,aADA,QAIA,mBAAsD,wCAA+D,SAGrH,MAIA,8BC1FA,CAEA,cAA4B,0BAG5B,CAgBA,iBACA,qBACA,OACA,yBACA,0CACA,iBACA,OACA,UAkGA,iBACA,QAEA,YADA,uCAEA,0BACA,MACA,QAGA,CAjIA,uCACA,CACA,qBACA,2BAEA,+BAAqD,IACrD,gBACA,aACA,eACA,QACA,SACA,QACA,CACA,GAWA,YACA,gBAAmB,mCACnB,iBAAmB,+BACnB,kBAAoB,2CACpB,iBACA,yBACA,sCACA,MACA,iBACA,+BACA,iCACA,qCACA,gBAAa,OACb,aACA,sBACA,gBACA,SACA,qBACA,KACA,qBACA,gBACA,4DACA,gBACA,KACA,uBAAyB,2BACzB,oBACA,kCACA,aACA,MADqB,MAAiB,QAEtC,qBAAuB,WACvB,mBACA,gCACA,2FACA,yCAEA,uFACA,EACA,wBACA,gCACA,oEACA,EACA,uBACA,uBACA,mBAAiC,0BACjC,kCACA,iBACA,KAGA,2BAFA,UAEK,KACL,mCACA,6BACA,iCAEA,UACA,CACA,qBAAsB,6CACtB,8BACA,MACA,gBAAS,OAAgB,IACzB,QAAa,MAAqB,YAClC,CACA,uBACA,oBACA,6DACA,QACA,GACA,iBAEA,4BACA,wBACA,iBAEA,cAA8B,oBAC9B,0BACA,CACA,yEACA,IACA,QACA,0BAA2C,CAAwB,QAEnE,8BACA,QAAU,kBAAyB,aACnC,EAAC,GACD,kCAEA,yBACA,6BACA,oBACG,oDACH,cAEA,2BACA,YAAuB,KACvB,SAYA,0BACA,0BACA,qCACA,GACA,QAEA,uBACA,SACA,qBACA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","file":"highlighter.js","sourcesContent":[" \tself[\"webpackChunk\"] = function webpackChunkCallback(chunkIds, moreModules) {\n \t\tfor(var moduleId in moreModules) {\n \t\t\tmodules[moduleId] = moreModules[moduleId];\n \t\t}\n \t\twhile(chunkIds.length)\n \t\t\tinstalledChunks[chunkIds.pop()] = 1;\n \t};\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded chunks\n \t// \"1\" means \"already loaded\"\n \tvar installedChunks = {\n \t\t\"highlighter\": 1\n \t};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n \t// This file contains only the entry chunk.\n \t// The chunk loading function for additional chunks\n \t__webpack_require__.e = function requireEnsure(chunkId) {\n \t\tvar promises = [];\n \t\tpromises.push(Promise.resolve().then(function() {\n \t\t\t// \"1\" is the signal for \"already loaded\"\n \t\t\tif(!installedChunks[chunkId]) {\n \t\t\t\timportScripts(\"highlighter/\" + chunkId + \".js\");\n \t\t\t}\n \t\t}));\n \t\treturn Promise.all(promises);\n \t};\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n/* Just enough of CodeMirror to run runMode under node.js */\n\nfunction splitLines(string){return string.split(/\\r\\n?|\\n/);};\n\n// Counts the column offset in a string, taking tabs into account.\n// Used mostly to find indentation.\nvar countColumn = exports.countColumn = function(string, end, tabSize, startIndex, startValue) {\n  if (end == null) {\n    end = string.search(/[^\\s\\u00a0]/);\n    if (end == -1) end = string.length;\n  }\n  for (var i = startIndex || 0, n = startValue || 0;;) {\n    var nextTab = string.indexOf(\"\\t\", i);\n    if (nextTab < 0 || nextTab >= end)\n      return n + (end - i);\n    n += nextTab - i;\n    n += tabSize - (n % tabSize);\n    i = nextTab + 1;\n  }\n};\n\nfunction StringStream(string, tabSize, context) {\n  this.pos = this.start = 0;\n  this.string = string;\n  this.tabSize = tabSize || 8;\n  this.lastColumnPos = this.lastColumnValue = 0;\n  this.lineStart = 0;\n  this.context = context\n};\n\nStringStream.prototype = {\n  eol: function() {return this.pos >= this.string.length;},\n  sol: function() {return this.pos == this.lineStart;},\n  peek: function() {return this.string.charAt(this.pos) || undefined;},\n  next: function() {\n    if (this.pos < this.string.length)\n      return this.string.charAt(this.pos++);\n  },\n  eat: function(match) {\n    var ch = this.string.charAt(this.pos);\n    if (typeof match == \"string\") var ok = ch == match;\n    else var ok = ch && (match.test ? match.test(ch) : match(ch));\n    if (ok) {++this.pos; return ch;}\n  },\n  eatWhile: function(match) {\n    var start = this.pos;\n    while (this.eat(match)){}\n    return this.pos > start;\n  },\n  eatSpace: function() {\n    var start = this.pos;\n    while (/[\\s\\u00a0]/.test(this.string.charAt(this.pos))) ++this.pos;\n    return this.pos > start;\n  },\n  skipToEnd: function() {this.pos = this.string.length;},\n  skipTo: function(ch) {\n    var found = this.string.indexOf(ch, this.pos);\n    if (found > -1) {this.pos = found; return true;}\n  },\n  backUp: function(n) {this.pos -= n;},\n  column: function() {\n    if (this.lastColumnPos < this.start) {\n      this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);\n      this.lastColumnPos = this.start;\n    }\n    return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);\n  },\n  indentation: function() {\n    return countColumn(this.string, null, this.tabSize) -\n      (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);\n  },\n  match: function(pattern, consume, caseInsensitive) {\n    if (typeof pattern == \"string\") {\n      var cased = function(str) {return caseInsensitive ? str.toLowerCase() : str;};\n      var substr = this.string.substr(this.pos, pattern.length);\n      if (cased(substr) == cased(pattern)) {\n        if (consume !== false) this.pos += pattern.length;\n        return true;\n      }\n    } else {\n      var match = this.string.slice(this.pos).match(pattern);\n      if (match && match.index > 0) return null;\n      if (match && consume !== false) this.pos += match[0].length;\n      return match;\n    }\n  },\n  current: function(){return this.string.slice(this.start, this.pos);},\n  hideFirstChars: function(n, inner) {\n    this.lineStart += n;\n    try { return inner(); }\n    finally { this.lineStart -= n; }\n  },\n  lookAhead: function(n) {\n    var line = this.context.line + n\n    return line >= this.context.lines.length ? null : this.context.lines[line]\n  }\n};\nexports.StringStream = StringStream;\n\nexports.startState = function(mode, a1, a2) {\n  return mode.startState ? mode.startState(a1, a2) : true;\n};\n\nvar modes = exports.modes = {}, mimeModes = exports.mimeModes = {};\nexports.defineMode = function(name, mode) {\n  if (arguments.length > 2)\n    mode.dependencies = Array.prototype.slice.call(arguments, 2);\n  modes[name] = mode;\n};\nexports.defineMIME = function(mime, spec) { mimeModes[mime] = spec; };\n\nexports.defineMode(\"null\", function() {\n  return {token: function(stream) {stream.skipToEnd();}};\n});\nexports.defineMIME(\"text/plain\", \"null\");\n\nexports.resolveMode = function(spec) {\n  if (typeof spec == \"string\" && mimeModes.hasOwnProperty(spec)) {\n    spec = mimeModes[spec];\n  } else if (spec && typeof spec.name == \"string\" && mimeModes.hasOwnProperty(spec.name)) {\n    spec = mimeModes[spec.name];\n  }\n  if (typeof spec == \"string\") return {name: spec};\n  else return spec || {name: \"null\"};\n};\n\nfunction copyObj(obj, target, overwrite) {\n  if (!target) target = {};\n  for (var prop in obj)\n    if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))\n      target[prop] = obj[prop];\n  return target;\n}\n\n// This can be used to attach properties to mode objects from\n// outside the actual mode definition.\nvar modeExtensions = exports.modeExtensions = {};\nexports.extendMode = function(mode, properties) {\n  var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});\n  copyObj(properties, exts);\n};\n\nexports.getMode = function(options, spec) {\n  var spec = exports.resolveMode(spec);\n  var mfactory = modes[spec.name];\n  if (!mfactory) return exports.getMode(options, \"text/plain\");\n  var modeObj = mfactory(options, spec);\n  if (modeExtensions.hasOwnProperty(spec.name)) {\n    var exts = modeExtensions[spec.name];\n    for (var prop in exts) {\n      if (!exts.hasOwnProperty(prop)) continue;\n      if (modeObj.hasOwnProperty(prop)) modeObj[\"_\" + prop] = modeObj[prop];\n      modeObj[prop] = exts[prop];\n    }\n  }\n  modeObj.name = spec.name;\n  if (spec.helperType) modeObj.helperType = spec.helperType;\n  if (spec.modeProps) for (var prop in spec.modeProps)\n    modeObj[prop] = spec.modeProps[prop];\n\n  return modeObj;\n};\n\nexports.innerMode = function(mode, state) {\n  var info;\n  while (mode.innerMode) {\n    info = mode.innerMode(state);\n    if (!info || info.mode == mode) break;\n    state = info.state;\n    mode = info.mode;\n  }\n  return info || {mode: mode, state: state};\n}\n\nexports.registerHelper = exports.registerGlobalHelper = Math.min;\n\nexports.runMode = function(string, modespec, callback, options) {\n  var mode = exports.getMode({indentUnit: 2}, modespec);\n  var lines = splitLines(string), state = (options && options.state) || exports.startState(mode);\n  var context = {lines: lines, line: 0}\n  for (var i = 0, e = lines.length; i < e; ++i, ++context.line) {\n    if (i) callback(\"\\n\");\n    var stream = new exports.StringStream(lines[i], 4, context);\n    if (!stream.string && mode.blankLine) mode.blankLine(state);\n    while (!stream.eol()) {\n      var style = mode.token(stream, state);\n      callback(stream.current(), style, i, stream.start, state);\n      stream.start = stream.pos;\n    }\n  }\n};\n\nrequire.cache[require.resolve(\"../../lib/codemirror\")] = require.cache[require.resolve(\"./runmode.node\")];\nrequire.cache[require.resolve(\"../../addon/runmode/runmode\")] = require.cache[require.resolve(\"./runmode.node\")];\n","/// <reference path=\"./globals.d.ts\" />\n\n// This doesn't import all of CodeMirror, instead it only imports\n// a small subset. This hack is brought to you by webpack and you\n// can read all about it in webpack.common.js.\nimport {\n  getMode,\n  innerMode,\n  StringStream,\n} from 'codemirror/addon/runmode/runmode.node.js'\n\nimport { ITokens, IHighlightRequest } from '../lib/highlighter/types'\n\n/**\n * A mode definition object is used to map a certain file\n * extension to a mode loader (see the documentation for\n * the install property).\n */\ninterface IModeDefinition {\n  /**\n   * A function that, when called, will attempt to asynchronously\n   * load the required modules for a particular mode. This function\n   * is idempotent and can be called multiple times with no adverse\n   * effect.\n   */\n  readonly install: () => Promise<void>\n\n  /**\n   * A map between file extensions (including the leading dot, i.e.\n   * \".jpeg\") and the selected mime type to use when highlighting\n   * that extension as specified in the CodeMirror mode itself.\n   */\n  readonly extensions: {\n    readonly [key: string]: string\n  }\n}\n\n/**\n * Array describing all currently supported modes and the file extensions\n * that they cover.\n */\nconst modes: ReadonlyArray<IModeDefinition> = [\n  {\n    install: () => import('codemirror/mode/javascript/javascript'),\n    extensions: {\n      '.ts': 'text/typescript',\n      '.js': 'text/javascript',\n      '.json': 'application/json',\n    },\n  },\n  {\n    install: () => import('codemirror/mode/coffeescript/coffeescript'),\n    extensions: {\n      '.coffee': 'text/x-coffeescript',\n    },\n  },\n  {\n    install: () => import('codemirror/mode/jsx/jsx'),\n    extensions: {\n      '.tsx': 'text/typescript-jsx',\n      '.jsx': 'text/jsx',\n    },\n  },\n  {\n    install: () => import('codemirror/mode/htmlmixed/htmlmixed'),\n    extensions: {\n      '.html': 'text/html',\n      '.htm': 'text/html',\n    },\n  },\n  {\n    install: () => import('codemirror/mode/htmlembedded/htmlembedded'),\n    extensions: {\n      '.jsp': 'application/x-jsp',\n    },\n  },\n  {\n    install: () => import('codemirror/mode/css/css'),\n    extensions: {\n      '.css': 'text/css',\n      '.scss': 'text/x-scss',\n      '.less': 'text/x-less',\n    },\n  },\n  {\n    install: () => import('codemirror/mode/vue/vue'),\n    extensions: {\n      '.vue': 'text/x-vue',\n    },\n  },\n  {\n    install: () => import('codemirror/mode/markdown/markdown'),\n    extensions: {\n      '.markdown': 'text/x-markdown',\n      '.md': 'text/x-markdown',\n    },\n  },\n  {\n    install: () => import('codemirror/mode/yaml/yaml'),\n    extensions: {\n      '.yaml': 'text/yaml',\n      '.yml': 'text/yaml',\n    },\n  },\n  {\n    install: () => import('codemirror/mode/xml/xml'),\n    extensions: {\n      '.xml': 'text/xml',\n      '.xaml': 'text/xml',\n      '.csproj': 'text/xml',\n      '.fsproj': 'text/xml',\n      '.vcxproj': 'text/xml',\n      '.vbproj': 'text/xml',\n      '.svg': 'text/xml',\n    },\n  },\n  {\n    install: () => import('codemirror/mode/clike/clike'),\n    extensions: {\n      '.m': 'text/x-objectivec',\n      '.scala': 'text/x-scala',\n      '.sc': 'text/x-scala',\n      '.cs': 'text/x-csharp',\n      '.cake': 'text/x-csharp',\n      '.java': 'text/x-java',\n      '.c': 'text/x-c',\n      '.h': 'text/x-c',\n      '.cpp': 'text/x-c++src',\n      '.hpp': 'text/x-c++src',\n      '.kt': 'text/x-kotlin',\n    },\n  },\n  {\n    install: () => import('codemirror/mode/mllike/mllike'),\n    extensions: {\n      '.ml': 'text/x-ocaml',\n      '.fs': 'text/x-fsharp',\n      '.fsx': 'text/x-fsharp',\n      '.fsi': 'text/x-fsharp',\n    },\n  },\n  {\n    install: () => import('codemirror/mode/swift/swift'),\n    extensions: {\n      '.swift': 'text/x-swift',\n    },\n  },\n  {\n    install: () => import('codemirror/mode/shell/shell'),\n    extensions: {\n      '.sh': 'text/x-sh',\n    },\n  },\n  {\n    install: () => import('codemirror/mode/sql/sql'),\n    extensions: {\n      '.sql': 'text/x-sql',\n    },\n  },\n  {\n    install: () => import('codemirror/mode/cypher/cypher'),\n    extensions: {\n      '.cql': 'application/x-cypher-query',\n    },\n  },\n  {\n    install: () => import('codemirror/mode/go/go'),\n    extensions: {\n      '.go': 'text/x-go',\n    },\n  },\n  {\n    install: () => import('codemirror/mode/perl/perl'),\n    extensions: {\n      '.pl': 'text/x-perl',\n    },\n  },\n  {\n    install: () => import('codemirror/mode/php/php'),\n    extensions: {\n      '.php': 'application/x-httpd-php',\n    },\n  },\n  {\n    install: () => import('codemirror/mode/python/python'),\n    extensions: {\n      '.py': 'text/x-python',\n    },\n  },\n  {\n    install: () => import('codemirror/mode/ruby/ruby'),\n    extensions: {\n      '.rb': 'text/x-ruby',\n    },\n  },\n  {\n    install: () => import('codemirror/mode/clojure/clojure'),\n    extensions: {\n      '.clj': 'text/x-clojure',\n      '.cljc': 'text/x-clojure',\n      '.cljs': 'text/x-clojure',\n      '.edn': 'text/x-clojure',\n    },\n  },\n  {\n    install: () => import('codemirror/mode/rust/rust'),\n    extensions: {\n      '.rs': 'text/x-rustsrc',\n    },\n  },\n  {\n    install: () => import('codemirror-mode-elixir'),\n    extensions: {\n      '.ex': 'text/x-elixir',\n      '.exs': 'text/x-elixir',\n    },\n  },\n  {\n    install: () => import('codemirror/mode/haxe/haxe'),\n    extensions: {\n      '.hx': 'text/x-haxe',\n    },\n  },\n  {\n    install: () => import('codemirror/mode/r/r'),\n    extensions: {\n      '.r': 'text/x-rsrc',\n    },\n  },\n  {\n    install: () => import('codemirror/mode/powershell/powershell'),\n    extensions: {\n      '.ps1': 'application/x-powershell',\n    },\n  },\n]\n\n/**\n * A map between file extensions and mime types, see\n * the 'extensions' property on the IModeDefinition interface\n * for more information\n */\nconst extensionMIMEMap = new Map<string, string>()\n\n/**\n * A map between mime types and mode definitions. See the\n * documentation for the IModeDefinition interface\n * for more information\n */\nconst mimeModeMap = new Map<string, IModeDefinition>()\n\nfor (const mode of modes) {\n  for (const [extension, mimeType] of Object.entries(mode.extensions)) {\n    extensionMIMEMap.set(extension, mimeType)\n    mimeModeMap.set(mimeType, mode)\n  }\n}\n\nfunction guessMimeType(contents: string) {\n  if (contents.startsWith('<?xml')) {\n    return 'text/xml'\n  }\n\n  if (contents.startsWith('#!')) {\n    const m = /^#!.*?(ts-node|node|bash|sh|python(?:[\\d.]+)?)\\r?\\n/g.exec(\n      contents\n    )\n\n    if (m) {\n      switch (m[1]) {\n        case 'ts-node':\n          return 'text/typescript'\n        case 'node':\n          return 'text/javascript'\n        case 'sh':\n        case 'bash':\n          return 'text/x-sh'\n        case 'perl':\n          return 'text/x-perl'\n      }\n\n      if (m[1].startsWith('python')) {\n        return 'text/x-python'\n      }\n    }\n  }\n\n  return null\n}\n\nasync function detectMode(\n  request: IHighlightRequest\n): Promise<CodeMirror.Mode<{}> | null> {\n  const mimeType =\n    extensionMIMEMap.get(request.extension.toLowerCase()) ||\n    guessMimeType(request.contents)\n\n  if (!mimeType) {\n    return null\n  }\n\n  const modeDefinition = mimeModeMap.get(mimeType)\n\n  if (modeDefinition === undefined) {\n    return null\n  }\n\n  await modeDefinition.install()\n\n  return getMode({}, mimeType) || null\n}\n\nfunction getModeName(mode: CodeMirror.Mode<{}>): string | null {\n  const name = (mode as any).name\n  return name && typeof name === 'string' ? name : null\n}\n\n/**\n * Helper method to determine the name of the innermost (i.e. current)\n * mode. Think of this as an abstraction over CodeMirror's innerMode\n * with added type guards.\n */\nfunction getInnerModeName(\n  mode: CodeMirror.Mode<{}>,\n  state: any\n): string | null {\n  const inner = innerMode(mode, state)\n  return inner && inner.mode ? getModeName(inner.mode) : null\n}\n\n/**\n * Extract the next token from the line stream or null if no token\n * could be extracted from the current position in the line stream.\n *\n * This method is more or less equal to the readToken method in\n * CodeMirror but since the readToken class in CodeMirror isn't included\n * in the Node runmode we're not able to use it.\n *\n * Worth noting here is that we're also replicated the workaround for\n * modes that aren't adhering to the rules of never returning without\n * advancing the line stream by trying it again (up to ten times). See\n * https://github.com/codemirror/CodeMirror/commit/2c60a2 for more\n * details on that.\n *\n * @param mode         The current (outer) mode\n * @param stream       The StringStream for the current line\n * @param state        The current mode state (if any)\n * @param addModeClass Whether or not to append the current (inner) mode name\n *                     as an extra CSS clas to the token, indicating the mode\n *                     that produced it, prefixed with \"cm-m-\". For example,\n *                     tokens from the XML mode will get the cm-m-xml class.\n */\nfunction readToken(\n  mode: CodeMirror.Mode<{}>,\n  stream: StringStream,\n  state: any,\n  addModeClass: boolean\n): string | null {\n  for (let i = 0; i < 10; i++) {\n    const innerModeName = addModeClass ? getInnerModeName(mode, state) : null\n    const token = mode.token(stream, state)\n\n    if (stream.pos > stream.start) {\n      return token && innerModeName ? `m-${innerModeName} ${token}` : token\n    }\n  }\n\n  throw new Error(`Mode ${getModeName(mode)} failed to advance stream.`)\n}\n\nonmessage = async (ev: MessageEvent) => {\n  const request = ev.data as IHighlightRequest\n\n  const tabSize = request.tabSize || 4\n  const contents = request.contents\n  const addModeClass = request.addModeClass === true\n\n  const mode = await detectMode(request)\n\n  if (!mode) {\n    postMessage({})\n    return\n  }\n\n  const lineFilter =\n    request.lines && request.lines.length\n      ? new Set<number>(request.lines)\n      : null\n\n  // If we've got a set of requested lines we can keep track of the maximum\n  // line we need so that we can bail immediately when we've reached it.\n  const maxLine = lineFilter ? Math.max(...lineFilter) : null\n\n  const lines = contents.split(/\\r?\\n/)\n  const state: any = mode.startState ? mode.startState() : null\n\n  const tokens: ITokens = {}\n\n  for (const [ix, line] of lines.entries()) {\n    // No need to continue after the max line\n    if (maxLine !== null && ix > maxLine) {\n      break\n    }\n\n    // For stateless modes we can optimize by only running\n    // the tokenizer over lines we care about.\n    if (lineFilter && !state) {\n      if (!lineFilter.has(ix)) {\n        continue\n      }\n    }\n\n    if (!line.length) {\n      if (mode.blankLine) {\n        mode.blankLine(state)\n      }\n\n      continue\n    }\n\n    const lineCtx = { lines, line: ix }\n    const lineStream = new StringStream(line, tabSize, lineCtx)\n\n    while (!lineStream.eol()) {\n      const token = readToken(mode, lineStream, state, addModeClass)\n\n      if (token && (!lineFilter || lineFilter.has(ix))) {\n        tokens[ix] = tokens[ix] || {}\n        tokens[ix][lineStream.start] = {\n          length: lineStream.pos - lineStream.start,\n          token,\n        }\n      }\n\n      lineStream.start = lineStream.pos\n    }\n  }\n\n  postMessage(tokens)\n}\n"],"sourceRoot":""}